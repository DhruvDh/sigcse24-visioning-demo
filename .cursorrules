# Demo: Constructivist Teaching with LLMs

## Project Structure

```text
src/
├── app/                    # Next.js App Router
│   ├── layout.tsx         # Root layout with font configurations
│   ├── page.tsx           # Landing page
│   └── globals.css        # Global styles
├── components/
│   ├── demo/              # Demo-specific components
│   │   ├── Introduction.tsx
│   │   ├── Questions.tsx
│   │   └── Tutorial.tsx
│   └── ui/               # Shared UI components
│       ├── Typography.tsx
│       └── Animations.tsx
├── lib/
│   ├── machines/         # XState machines
│   ├── store/           # Zustand store
│   └── hooks/           # Custom hooks
└── styles/              # Additional style modules
```

## Font Usage

The project uses IBM Plex font family:

```typescript
// In components, use Tailwind classes:
<h1 className="font-serif">    // IBM Plex Serif
<p className="font-sans">      // IBM Plex Sans
<code className="font-mono">   // IBM Plex Mono

// Typography scale examples:
text-base font-serif    // Base serif text
text-lg font-sans      // Larger sans text
text-2xl font-serif    // Large serif headings

// Animation examples:
animate-fade-in       // Fade in animation
animate-fade-out      // Fade out animation
```

## Project Overview

Building a demo for a university booth showcasing how LLMs can be taught to teach using constructivist principles. The demo focuses on teaching mergesort through a constructivist approach, with synthetic student responses generated by another LLM.

## Key Features

1. Interactive onboarding flow with vision questions
2. Typography-focused design using IBM Plex Sans and Serif
3. Smooth animations enhancing typographic elements
4. Dynamic synthetic student responses
5. State machine-driven demo flow

## Technical Stack

- Next.js 15.0.4
- React 19.0.0
- TypeScript 5.7.2
- Tailwind CSS 3.4.16
- XState for state management
- Zustand for global state
- Framer Motion for animations
- IBM Plex fonts

## Architecture Decisions

1. Using XState for demo flow management to handle complex state transitions
2. Typography-first design approach with careful attention to animations
3. Separation of LLM roles (teacher vs. synthetic students)
4. Minimal, focused UI with emphasis on text presentation

## Key Components Structure

- Onboarding flow (welcome, name input)
- Vision questions about teaching LLMs
- Mergesort tutorial demonstration
- Synthetic student response selection
- Typography components with animations

## State Management

1. XState machine handles demo flow
2. Zustand manages global state
3. State includes:
   - Current demo step
   - User responses to vision questions
   - Selected student persona
   - Tutorial progress

## Styling Guidelines

1. Use IBM Plex Sans for UI elements
2. Use IBM Plex Serif for educational content
3. Implement smooth transitions between states
4. Focus on typographic hierarchy and spacing
5. Use animations to enhance text prominence

## Animation Guidelines

1. Subtle text fade-ins and transitions
2. Smooth step transitions
3. Typography-focused motion design
4. No flashy or distracting animations

## Code Organization

- `/app` - Next.js app router structure
- `/components` - Reusable UI components
- `/machines` - XState definitions
- `/store` - Zustand store
- `/styles` - Global styles and typography
- `/lib` - Utilities and hooks

## Testing Considerations

1. State transitions
2. Typography rendering
3. Animation performance
4. LLM response handling

## Performance Guidelines

1. Optimize typography loading
2. Minimize animation impact
3. Efficient state management
4. Responsive design considerations

## Development Priorities

1. Set up typography system
2. Implement state machine
3. Create basic flow
4. Add animations
5. Integrate LLM responses
6. Polish UI/UX

## Accessibility Guidelines

1. Maintain text contrast
2. Ensure keyboard navigation
3. Support screen readers
4. Respect reduced motion preferences

When implementing new features or making changes:

1. Follow typographic principles
2. Maintain clean state transitions
3. Keep animations subtle and purposeful
4. Prioritize readability and clarity
5. Ensure responsive behavior

## Component Organization

1. Page Components
   - Located in `src/app`
   - Use page.tsx for main routes
   - Keep pages thin, delegate to components

2. Demo Components
   - Located in `src/components/demo`
   - Each major demo section has its own component
   - Use composition for complex features

3. UI Components
   - Located in `src/components/ui`
   - Reusable, atomic design principles
   - Consistent typography and animation patterns

4. Typography Components

   ```typescript
   // Example Typography component
   const Heading = ({ children, className }: PropsWithChildren<{ className?: string }>) => (
     <h2 className={clsx(
       "font-serif text-2xl leading-relaxed mb-6",
       "animate-fade-in",
       className
     )}>
       {children}
     </h2>
   );
   ```

5. Animation Components

   ```typescript
   // Example animated text component
   const AnimatedText = ({ children }: PropsWithChildren) => (
     <motion.div
       initial={{ opacity: 0, y: 20 }}
       animate={{ opacity: 1, y: 0 }}
       className="font-sans"
     >
       {children}
     </motion.div>
   );
   ```

## Style Enforcement

- Use TypeScript strictly
- Follow Tailwind class ordering
- Maintain consistent component patterns
- Follow Next.js best practices

## Deno KV: Key/Value database - Deno by Example

> ## Excerpt
>
> In-depth documentation, guides, and reference materials for building secure, high-performance JavaScript and TypeScript applications with Deno

IMPORTANT: PLEASE IGNORE LINTS AND ERRORS IN DENO TYPESCRIPT FILES. THE TYPESCRIPT LANGUAGE SERVER INSERTS ERRORS WHEN IT SHOULD NOT. ONLY THE `deno` SOURCE FOR DIAGNOSTICS IS CORRECT.

```typescript
/**
 * @title Deno KV: Key/Value database
 * @difficulty intermediate
 * @tags cli, deploy
 * @run --unstable-kv <url>
 * @resource {https://docs.deno.com/deploy/kv/manual} Deno KV user guide
 * @resource {https://docs.deno.com/api/deno/~/Deno.Kv} Deno KV Runtime API docs
 * @group Unstable APIs
 *
 * <strong>Warning: This is an unstable API that is subject to change or removal at anytime.</strong><br>Deno KV is a key/value database built in to the Deno runtime, and works with
 * zero configuration on Deno Deploy. It's great for use cases that require fast
 * reads and don't require the query flexibility of a SQL database.
 */

// Open the default database
const kv = await Deno.openKv();

// Define an interface in TypeScript for our data
enum Rank {
  Bronze,
  Silver,
  Gold,
}

interface Player {
  username: string;
  rank: Rank;
}

// Create a few instances for testing
const player1: Player = { username: "carlos", rank: Rank.Bronze };
const player2: Player = { username: "briana", rank: Rank.Silver };
const player3: Player = { username: "alice", rank: Rank.Bronze };

// Store object data in Deno KV using the "set" operation. Keys can be arranged
// hierarchically, not unlike resources in a REST API.
await kv.set(["players", player1.username], player1);
await kv.set(["players", player2.username], player2);
await kv.set(["players", player3.username], player3);

// The "set" operation is used to both create and update data for a given key
player3.rank = Rank.Gold;
await kv.set(["players", player3.username], player3);

// Fetch a single object by key with the "get" operation
const record = await kv.get(["players", "alice"]);
const alice: Player = record.value as Player;
console.log(record.key, record.versionstamp, alice);

// Fetch several objects by key with "getMany"
const [record1, record2] = await kv.getMany([
  ["players", "carlos"],
  ["players", "briana"],
]);
console.log(record1, record2);

// List several records by key prefix - note that results are ordered
// lexicographically, so our players will be fetched in the order
// "alice", "briana", "carlos"
const records = kv.list({ prefix: ["players"] });
const players = [];
for await (const res of records) {
  players.push(res.value as Player);
}
console.log(players);

// Delete a value for a given key
await kv.delete(["players", "carlos"]);

// The Deno.KvU64 object is a wrapper for 64 bit integers (BigInt), so you can
// quickly update very large numbers. Let's add a "score" for alice.
const aliceScoreKey = ["scores", "alice"];
await kv.set(aliceScoreKey, new Deno.KvU64(0n));

// To prepare an atomic transaction to update the score, first we need to
// check if the score has been modified since we read it. We can use the
// versionstamp to check if the value has been modified since we read it.
const aliceScoreEntry = await kv.get<Deno.KvU64>(aliceScoreKey);
const atomicCheck = {
  key: aliceScoreEntry.key,
  versionstamp: aliceScoreEntry.versionstamp,
};

// Add 10 to the player's score in an atomic transaction
const res = await kv.atomic()
  .check(atomicCheck)
  .mutate({
    type: "sum",
    key: aliceScoreKey,
    value: new Deno.KvU64(10n),
  })
  .commit();
// Check if the transaction was successful
if (res.ok) {
  const newScore = (await kv.get<Deno.KvU64>(aliceScoreKey)).value;
  console.log("Alice's new score is:", newScore);
} else {
  console.error("Transaction failed ");
  // Optionally, implement retry logic or handle the conflict
}
```

# AI Tutor Implementation Guide

## Core Teaching Philosophy

1. **Constructivist Approach**
   - Guide discovery rather than direct instruction
   - Build on student's existing understanding
   - Never explain concepts before students have a chance to discover them
   - Use carefully chosen examples to lead to insights
   - Track genuine understanding through milestones

2. **Teaching Persona**
   - Professional but approachable
   - Patient and encouraging
   - Adapts to student's pace
   - Maintains clear direction
   - Shows genuine interest in student's thinking

3. **Session Structure**
   - 30-45 minute interactive experience
   - Progress tracking through milestones
   - Dynamic response generation
   - Guided discovery of merge sort
   - Focus on student-led insights

## Implementation Components

1. **State Management Integration**

   ```typescript
   interface TeachingState {
     currentMilestone: string;
     completedMilestones: string[];
     studentResponses: StudentResponse[];
     currentExample: number[];
     teachingPhase: 'discovery' | 'development' | 'mastery';
   }
   ```

2. **Response Generation**
   - Parse student understanding level
   - Select appropriate next example
   - Generate constructivist questions
   - Validate genuine understanding
   - Track milestone progress

3. **Question Design**

   ```typescript
   interface TeachingQuestion {
     type: 'discovery' | 'verification' | 'extension';
     content: string;
     expectedInsight: string;
     followUp: string[];
     validation: string[];
   }
   ```

## Milestone Framework

1. **Inefficiency Discovery**
   - Guide comparison of sorting approaches
   - Build pattern recognition skills
   - Let students discover computational complexity
   - Use concrete examples with clear patterns
   - Track steps for different input sizes

2. **Divide-and-Conquer Insight**
   - Build from binary search understanding
   - Guide discovery of splitting benefits
   - Use small, tractable examples
   - Compare work before and after splitting
   - Let students propose splitting idea

3. **Merging Development**
   - Start with pre-sorted small arrays
   - Guide systematic comparison discovery
   - Build understanding of merge process
   - Use visual aids for clarity
   - Track development of merging strategy

4. **Recursive Pattern Recognition**
   - Build understanding level by level
   - Guide discovery of repeated patterns
   - Use tree visualization
   - Connect to previous insights
   - Let students discover recursive nature

## Implementation Guidelines

1. **Response Processing**

   ```typescript
   interface StudentResponse {
     content: string;
     type: 'question' | 'observation' | 'attempt';
     relatedMilestone?: string;
     comprehensionIndicators: string[];
   }
   ```

2. **Example Management**

   ```typescript
   interface TeachingExample {
     array: number[];
     complexity: 'basic' | 'intermediate' | 'advanced';
     insights: string[];
     visualAids: boolean;
     scaffolding: string[];
   }
   ```

3. **Visual Components**
   - Array visualization
   - Split step animation
   - Merge operation display
   - Progress tracking
   - Milestone indicators

## Recovery Strategies

1. **Understanding Gaps**
   - Return to last confirmed understanding
   - Use simpler examples
   - Break down concepts
   - Provide targeted practice
   - Build confidence through success

2. **Misconceptions**
   - Address immediately but gently
   - Use counterexamples
   - Guide self-correction
   - Reinforce correct understanding
   - Track resolution

## Response Generation Rules

1. **Question Formation**
   - Never ask yes/no questions
   - Focus on process explanation
   - Encourage prediction
   - Build on previous responses
   - Guide discovery naturally

2. **Feedback Design**

   ```typescript
   interface TeachingFeedback {
     type: 'guidance' | 'validation' | 'correction';
     content: string;
     nextStep: string;
     scaffolding?: string[];
   }
   ```

## Accessibility Implementation

1. **ARIA Landmarks and Roles**

   ```typescript
   // Main tutorial layout
   interface AccessibleLayout {
     regions: {
       navigation: "complementary" | "navigation";
       tutorial: "main";
       responses: "complementary";
     };
     landmarks: {
       milestones: "region";
       chat: "log";
       responses: "form";
     };
   }

   // Example implementation
   <nav role="navigation" aria-label="Learning milestones">
     <MilestonesPanel />
   </nav>
   <main role="main" aria-live="polite">
     <ChatArea />
   </main>
   <aside role="complementary" aria-label="Response options">
     <ResponsePanel />
   </aside>
   ```

2. **Dynamic Content Updates**

   ```typescript
   // Chat message structure
   interface ChatMessage {
     role: "tutor" | "student";
     content: string;
     ariaLabel: string;
     ariaLive: "off" | "polite" | "assertive";
   }

   // Implementation example
   <div 
     role="log" 
     aria-label="Tutorial conversation"
     aria-live="polite"
   >
     {messages.map(message => (
       <div 
         role="article"
         aria-label={`${message.role} message: ${message.ariaLabel}`}
       >
         {message.content}
       </div>
     ))}
   </div>
   ```

3. **Interactive Elements**

   ```typescript
   // Response option component
   interface ResponseOption {
     id: string;
     content: string;
     persona: string;
     ariaPressed?: boolean;
     ariaExpanded?: boolean;
     ariaControls?: string;
   }

   // Implementation example
   <button
     role="button"
     aria-haspopup="dialog"
     aria-expanded={isExpanded}
     aria-pressed={isSelected}
     aria-controls={`response-${id}`}
   >
     <span className="sr-only">{persona} responds:</span>
     {content}
   </button>
   ```

4. **Progress Tracking**

   ```typescript
   // Milestone structure
   interface AccessibleMilestone {
     id: string;
     text: string;
     isComplete: boolean;
     ariaLabel: string;
   }

   // Implementation example
   <div 
     role="list" 
     aria-label="Learning progress"
   >
     {milestones.map(milestone => (
       <div 
         role="listitem"
         aria-current={milestone.isComplete ? "true" : undefined}
         aria-label={`${milestone.text}: ${
           milestone.isComplete ? "completed" : "in progress"
         }`}
       >
         {milestone.text}
       </div>
     ))}
   </div>
   ```

5. **Focus Management**

   ```typescript
   // Focus control
   interface FocusState {
     currentFocus: string;
     lastInteraction: string;
     returnPoint?: string;
   }

   // Implementation helpers
   const FocusManager = {
     trapFocus: (containerId: string) => void;
     returnFocus: () => void;
     announceChange: (message: string) => void;
   };

   // Example usage
   useEffect(() => {
     if (newMessage) {
       FocusManager.announceChange("New message available");
       if (isUserResponse) {
         FocusManager.trapFocus("response-options");
       }
     }
   }, [newMessage]);
   ```

6. **Keyboard Navigation**

   ```typescript
   interface KeyboardControls {
     shortcuts: {
       nextResponse: "ArrowRight";
       previousResponse: "ArrowLeft";
       selectResponse: "Enter" | " ";
       openHelp: "h";
       showProgress: "p";
     };
     navigationOrder: string[];
   }

   // Implementation example
   <div onKeyDown={handleKeyboardNavigation} tabIndex={0}>
     <div role="navigation" aria-label="Response navigation">
       <button aria-keyshortcuts="ArrowLeft">Previous</button>
       <button aria-keyshortcuts="ArrowRight">Next</button>
     </div>
   </div>
   ```

7. **Error Prevention and Handling**

   ```typescript
   interface ErrorState {
     type: "warning" | "error";
     message: string;
     corrective_action?: string;
     aria: {
       live: "assertive";
       atomic: boolean;
       relevant: "additions" | "all";
     };
   }

   // Implementation example
   <div 
     role="alert" 
     aria-live="assertive"
     aria-atomic="true"
   >
     <p>{error.message}</p>
     {error.corrective_action && (
       <p aria-label="Suggested fix">{error.corrective_action}</p>
     )}
   </div>
   ```

8. **Screen Reader Optimization**

   ```typescript
   // Hidden text for context
   const ScreenReaderText = {
     visualContexts: {
       arraySplit: "Array is being split into two parts",
       arrayMerge: "Arrays are being merged in sorted order",
       comparison: "Comparing elements",
     },
     stateChanges: {
       milestoneComplete: (name: string) => 
         `Milestone completed: ${name}`,
       newMessage: "New message in chat",
       optionsAvailable: "New response options available",
     },
   };

   // Implementation example
   <span className="sr-only" aria-live="polite">
     {ScreenReaderText.visualContexts.arraySplit}
   </span>
   ```

9. **Responsive Interaction**

   ```typescript
   interface ResponsiveState {
     viewport: {
       size: "small" | "medium" | "large";
       orientation: "portrait" | "landscape";
     };
     ariaAdjustments: {
       labelledby: string[];
       describedby: string[];
     };
   }

   // Implementation example
   <div 
     aria-labelledby={
       viewport.size === "small" 
         ? "compact-label" 
         : "full-label"
     }
     aria-describedby={
       viewport.size === "small"
         ? "compact-desc"
         : "full-desc"
     }
   >
     {content}
   </div>
   ```

## Web Standards Compliance

1. **Document Structure**
   - Proper heading hierarchy (h1-h6)
   - Semantic HTML elements
   - Meaningful element sequence
   - Skip navigation links
   - Proper section labeling

2. **Interactive Elements**
   - Sufficient touch targets (minimum 44x44px)
   - Clear focus indicators
   - Appropriate hover states
   - Proper button/link usage
   - Form label associations

3. **Content Requirements**
   - Minimum contrast ratio: 4.5:1
   - Text resizing support (up to 200%)
   - No information conveyed by color alone
   - Proper link underlines
   - Clear error identification

Remember: This implementation ensures our demo meets WCAG 2.1 Level AA standards while maintaining the interactive teaching experience.

## Implementation Notes

1. The AI tutor should maintain awareness of:
   - Current milestone progress
   - Student's demonstrated understanding
   - Previous examples used
   - Recovery points if needed
   - Teaching phase requirements

2. Response generation should:
   - Match student's current level
   - Build on previous successes
   - Guide natural discovery
   - Provide appropriate scaffolding
   - Maintain forward momentum

3. Understanding verification must:
   - Use concrete examples
   - Require active demonstration
   - Check prediction accuracy
   - Validate genuine comprehension
   - Track milestone achievements

4. IMPORTANT: PLEASE DEVIATE FROM THE ABOVE GUIDELINES AS APPROPRIATE. THESE ARE MEANT TO BE ITERATIVE AND NOT SET IN STONE.
