# Demo: Constructivist Teaching with LLMs

## Project Structure

```text
src/
├── app/                    # Next.js App Router
│   ├── layout.tsx         # Root layout with font configurations
│   ├── page.tsx           # Landing page
│   └── globals.css        # Global styles
├── components/
│   ├── demo/              # Demo-specific components
│   │   ├── Introduction.tsx
│   │   ├── Questions.tsx
│   │   └── Tutorial.tsx
│   └── ui/               # Shared UI components
│       ├── Typography.tsx
│       └── Animations.tsx
├── lib/
│   ├── machines/         # XState machines
│   ├── store/           # Zustand store
│   └── hooks/           # Custom hooks
└── styles/              # Additional style modules
```

## Font Usage

The project uses IBM Plex font family:

```typescript
// In components, use Tailwind classes:
<h1 className="font-serif">    // IBM Plex Serif
<p className="font-sans">      // IBM Plex Sans
<code className="font-mono">   // IBM Plex Mono

// Typography scale examples:
text-base font-serif    // Base serif text
text-lg font-sans      // Larger sans text
text-2xl font-serif    // Large serif headings

// Animation examples:
animate-fade-in       // Fade in animation
animate-fade-out      // Fade out animation
```

## Project Overview

Building a demo for a university booth showcasing how LLMs can be taught to teach using constructivist principles. The demo focuses on teaching mergesort through a constructivist approach, with synthetic student responses generated by another LLM.

## Key Features

1. Interactive onboarding flow with vision questions
2. Typography-focused design using IBM Plex Sans and Serif
3. Smooth animations enhancing typographic elements
4. Dynamic synthetic student responses
5. State machine-driven demo flow

## Technical Stack

- Next.js 15.0.4
- React 19.0.0
- TypeScript 5.7.2
- Tailwind CSS 3.4.16
- XState for state management
- Zustand for global state
- Framer Motion for animations
- IBM Plex fonts

## Architecture Decisions

1. Using XState for demo flow management to handle complex state transitions
2. Typography-first design approach with careful attention to animations
3. Separation of LLM roles (teacher vs. synthetic students)
4. Minimal, focused UI with emphasis on text presentation

## Key Components Structure

- Onboarding flow (welcome, name input)
- Vision questions about teaching LLMs
- Mergesort tutorial demonstration
- Synthetic student response selection
- Typography components with animations

## State Management

1. XState machine handles demo flow
2. Zustand manages global state
3. State includes:
   - Current demo step
   - User responses to vision questions
   - Selected student persona
   - Tutorial progress

## Styling Guidelines

1. Use IBM Plex Sans for UI elements
2. Use IBM Plex Serif for educational content
3. Implement smooth transitions between states
4. Focus on typographic hierarchy and spacing
5. Use animations to enhance text prominence

## Animation Guidelines

1. Subtle text fade-ins and transitions
2. Smooth step transitions
3. Typography-focused motion design
4. No flashy or distracting animations

## Code Organization

- `/app` - Next.js app router structure
- `/components` - Reusable UI components
- `/machines` - XState definitions
- `/store` - Zustand store
- `/styles` - Global styles and typography
- `/lib` - Utilities and hooks

## Testing Considerations

1. State transitions
2. Typography rendering
3. Animation performance
4. LLM response handling

## Performance Guidelines

1. Optimize typography loading
2. Minimize animation impact
3. Efficient state management
4. Responsive design considerations

## Development Priorities

1. Set up typography system
2. Implement state machine
3. Create basic flow
4. Add animations
5. Integrate LLM responses
6. Polish UI/UX

## Accessibility Guidelines

1. Maintain text contrast
2. Ensure keyboard navigation
3. Support screen readers
4. Respect reduced motion preferences

When implementing new features or making changes:

1. Follow typographic principles
2. Maintain clean state transitions
3. Keep animations subtle and purposeful
4. Prioritize readability and clarity
5. Ensure responsive behavior

## Component Organization

1. Page Components
   - Located in `src/app`
   - Use page.tsx for main routes
   - Keep pages thin, delegate to components

2. Demo Components
   - Located in `src/components/demo`
   - Each major demo section has its own component
   - Use composition for complex features

3. UI Components
   - Located in `src/components/ui`
   - Reusable, atomic design principles
   - Consistent typography and animation patterns

4. Typography Components

   ```typescript
   // Example Typography component
   const Heading = ({ children, className }: PropsWithChildren<{ className?: string }>) => (
     <h2 className={clsx(
       "font-serif text-2xl leading-relaxed mb-6",
       "animate-fade-in",
       className
     )}>
       {children}
     </h2>
   );
   ```

5. Animation Components

   ```typescript
   // Example animated text component
   const AnimatedText = ({ children }: PropsWithChildren) => (
     <motion.div
       initial={{ opacity: 0, y: 20 }}
       animate={{ opacity: 1, y: 0 }}
       className="font-sans"
     >
       {children}
     </motion.div>
   );
   ```

## Style Enforcement

- Use TypeScript strictly
- Follow Tailwind class ordering
- Maintain consistent component patterns
- Follow Next.js best practices

## Deno KV: Key/Value database - Deno by Example

> ## Excerpt
>
> In-depth documentation, guides, and reference materials for building secure, high-performance JavaScript and TypeScript applications with Deno

IMPORTANT: PLEASE IGNORE LINTS AND ERRORS IN DENO TYPESCRIPT FILES. THE TYPESCRIPT LANGUAGE SERVER INSERTS ERRORS WHEN IT SHOULD NOT. ONLY THE `deno` SOURCE FOR DIAGNOSTICS IS CORRECT.

```typescript
/**
 * @title Deno KV: Key/Value database
 * @difficulty intermediate
 * @tags cli, deploy
 * @run --unstable-kv <url>
 * @resource {https://docs.deno.com/deploy/kv/manual} Deno KV user guide
 * @resource {https://docs.deno.com/api/deno/~/Deno.Kv} Deno KV Runtime API docs
 * @group Unstable APIs
 *
 * <strong>Warning: This is an unstable API that is subject to change or removal at anytime.</strong><br>Deno KV is a key/value database built in to the Deno runtime, and works with
 * zero configuration on Deno Deploy. It's great for use cases that require fast
 * reads and don't require the query flexibility of a SQL database.
 */

// Open the default database
const kv = await Deno.openKv();

// Define an interface in TypeScript for our data
enum Rank {
  Bronze,
  Silver,
  Gold,
}

interface Player {
  username: string;
  rank: Rank;
}

// Create a few instances for testing
const player1: Player = { username: "carlos", rank: Rank.Bronze };
const player2: Player = { username: "briana", rank: Rank.Silver };
const player3: Player = { username: "alice", rank: Rank.Bronze };

// Store object data in Deno KV using the "set" operation. Keys can be arranged
// hierarchically, not unlike resources in a REST API.
await kv.set(["players", player1.username], player1);
await kv.set(["players", player2.username], player2);
await kv.set(["players", player3.username], player3);

// The "set" operation is used to both create and update data for a given key
player3.rank = Rank.Gold;
await kv.set(["players", player3.username], player3);

// Fetch a single object by key with the "get" operation
const record = await kv.get(["players", "alice"]);
const alice: Player = record.value as Player;
console.log(record.key, record.versionstamp, alice);

// Fetch several objects by key with "getMany"
const [record1, record2] = await kv.getMany([
  ["players", "carlos"],
  ["players", "briana"],
]);
console.log(record1, record2);

// List several records by key prefix - note that results are ordered
// lexicographically, so our players will be fetched in the order
// "alice", "briana", "carlos"
const records = kv.list({ prefix: ["players"] });
const players = [];
for await (const res of records) {
  players.push(res.value as Player);
}
console.log(players);

// Delete a value for a given key
await kv.delete(["players", "carlos"]);

// The Deno.KvU64 object is a wrapper for 64 bit integers (BigInt), so you can
// quickly update very large numbers. Let's add a "score" for alice.
const aliceScoreKey = ["scores", "alice"];
await kv.set(aliceScoreKey, new Deno.KvU64(0n));

// To prepare an atomic transaction to update the score, first we need to
// check if the score has been modified since we read it. We can use the
// versionstamp to check if the value has been modified since we read it.
const aliceScoreEntry = await kv.get<Deno.KvU64>(aliceScoreKey);
const atomicCheck = {
  key: aliceScoreEntry.key,
  versionstamp: aliceScoreEntry.versionstamp,
};

// Add 10 to the player's score in an atomic transaction
const res = await kv.atomic()
  .check(atomicCheck)
  .mutate({
    type: "sum",
    key: aliceScoreKey,
    value: new Deno.KvU64(10n),
  })
  .commit();
// Check if the transaction was successful
if (res.ok) {
  const newScore = (await kv.get<Deno.KvU64>(aliceScoreKey)).value;
  console.log("Alice's new score is:", newScore);
} else {
  console.error("Transaction failed ");
  // Optionally, implement retry logic or handle the conflict
}
```
